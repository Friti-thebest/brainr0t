-- Cabeçalho e serviços
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local uis = game:GetService("UserInputService")
local ts = game:GetService("TeleportService")
local http = game:GetService("HttpService")
local runService = game:GetService("RunService")

-- Variáveis
local running = true
local minimized = false
local noclipEnabled = false
local superJumpEnabled = false
local espEnabled = false
local roubarEnabled = false
local roubarPlataforma = nil
local voandoRoubo = false
local espParts = {}
local goEnabled = false
local shiftlockEnabled = false

-- Detecta se é dispositivo móvel
local isMobile = game:GetService("UserInputService").TouchEnabled

-- Define o tamanho da interface baseado no dispositivo
local interfaceSize
local textSize
local buttonSize
local elementScale
if isMobile then
    interfaceSize = UDim2.fromOffset(150, 100)
    textSize = 8 -- Fonte ainda menor para mobile
    buttonSize = UDim2.new(0, 15, 0, 15) -- Botões ainda menores para mobile
    elementScale = 0.33 -- Escala de 1/3 para elementos móveis
else
    interfaceSize = UDim2.fromOffset(450, 300)
    textSize = 14
    buttonSize = UDim2.new(0, 30, 0, 30)
    elementScale = 1
end

-- Carrega a Kavo UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()

-- Cria a janela principal
local Window = Library.CreateLib("FRITISCRIPTS", "DarkTheme")

-- Força a interface a ser visível em dispositivos móveis
game:GetService("StarterGui"):SetCore("TouchCameraMovementMode", "UserChoice")
game:GetService("StarterGui"):SetCore("DevConsoleVisible", false)

-- Cria as abas
local MainTab = Window:NewTab("Principal")
local MovementSection = MainTab:NewSection("Movimentação")
local PlayerSection = MainTab:NewSection("Jogador")

-- Toggle para Noclip
MovementSection:NewToggle("Noclip", "Atravessa paredes", function(state)
    noclipEnabled = state
end)

-- Toggle para Super Jump
MovementSection:NewToggle("Super Jump", "Pulo alto", function(state)
    superJumpEnabled = state
end)

-- Toggle para ShiftLock
MovementSection:NewToggle("SHIFTLOCK", "Trava a câmera", function(state)
    shiftlockEnabled = state
    if state then
        game:GetService("Players").LocalPlayer.DevEnableMouseLock = true
    else
        game:GetService("Players").LocalPlayer.DevEnableMouseLock = false
    end
end)

-- Toggle para ESP
PlayerSection:NewToggle("ESP", "Veja outros jogadores", function(state)
    espEnabled = state
    if not state then
        for _, part in pairs(espParts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
        espParts = {}
    end
end)

-- Toggle para Roubar (Steal)
PlayerSection:NewToggle("Roubar (Steal)", "Plataforma e voo", function(state)
    roubarEnabled = state
    if not state then
        if roubarPlataforma and roubarPlataforma.Parent then
            roubarPlataforma:Destroy()
            roubarPlataforma = nil
        end
        voandoRoubo = false
    end
end)

-- Botão para Steal2
PlayerSection:NewButton("Steal2", "Teleporta para o jogador mais próximo", function()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (p.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = p
            end
        end
    end
    
    if nearestPlayer then
        player.Character.HumanoidRootPart.CFrame = nearestPlayer.Character.HumanoidRootPart.CFrame
    end
end)

-- Botão para Go
PlayerSection:NewButton("Go", "Voa até o jogador mais próximo", function()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (p.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = p
            end
        end
    end
    
    if nearestPlayer then
        local targetPos = nearestPlayer.Character.HumanoidRootPart.Position
        local direction = (targetPos - player.Character.HumanoidRootPart.Position).Unit
        local distance = (targetPos - player.Character.HumanoidRootPart.Position).Magnitude
        local speed = 2.05
        
        for i = 1, distance, speed do
            if not running then break end
            player.Character.HumanoidRootPart.CFrame = CFrame.new(
                player.Character.HumanoidRootPart.Position + direction * speed
            )
            wait()
        end
    end
end)

-- Teclado
uis.InputBegan:Connect(function(input, gameProcessed)
    if not running or gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.Space and superJumpEnabled then
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then 
            hrp.Velocity = Vector3.new(0, 120, 0) 
        end
    end
end)

-- Função para encontrar o jogador mais próximo
local function encontrarJogadorProximo()
    local jogadorMaisProximo = nil
    local menorDistancia = math.huge
    
    for _, p in ipairs(game.Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local distancia = (p.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distancia < menorDistancia then
                menorDistancia = distancia
                jogadorMaisProximo = p
            end
        end
    end
    
    return jogadorMaisProximo
end

-- Loop de execução
runService.RenderStepped:Connect(function()
    if not running then return end

    if noclipEnabled and player.Character then
        for _, part in ipairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end

    if espEnabled then
        for _, p in ipairs(game.Players:GetPlayers()) do
            if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and not espParts[p.Name] then
                local box = Instance.new("BoxHandleAdornment")
                box.Size = Vector3.new(6, 6, 6)
                box.Color3 = Color3.new(1, 0, 0)
                box.AlwaysOnTop = true
                box.ZIndex = 10
                box.Adornee = p.Character.HumanoidRootPart
                box.Transparency = 0.3
                box.Name = "ESPBox"
                box.Parent = p.Character.HumanoidRootPart
                espParts[p.Name] = box
            end
        end
    end

    if voandoRoubo and roubarPlataforma and player.Character then
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local targetPosition = roubarPlataforma.Position + Vector3.new(0, 3, 0)
            local dir = (targetPosition - hrp.Position)
            
            if dir.Magnitude < 3 then
                -- Chegou na plataforma
                hrp.Velocity = Vector3.zero
                voandoRoubo = false
            else
                -- Plana suavemente em direção à plataforma
                local velocidadeHorizontal = dir.Unit * 20
                local velocidadeVertical = Vector3.new(0, 0, 0)
                hrp.Velocity = (velocidadeHorizontal + velocidadeVertical) * 2.05
            end
        end
    end

    if goEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local alvoProximo = encontrarJogadorProximo()
        if alvoProximo then
            local hrp = player.Character.HumanoidRootPart
            local targetPosition = alvoProximo.Character.HumanoidRootPart.Position -- Remove o offset de altura para ficar na mesma altura
            local dir = (targetPosition - hrp.Position)
            
            -- Plana/voa em direção ao alvo
            local velocidadeHorizontal = dir.Unit * 25 -- Velocidade horizontal um pouco maior
            local velocidadeVertical = Vector3.new(0, 0, 0)
            hrp.Velocity = (velocidadeHorizontal + velocidadeVertical) * 2.05
        end
    end
end)

-- Função para destruir a UI quando necessário
local function Destroy()
    Window:Destroy()
end

-- Notificação inicial com delay para garantir que apareça
spawn(function()
    wait(1)
    for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
        if gui.Name == "KavoUI" then
            gui.Enabled = true
            gui.ResetOnSpawn = false
            -- Ajusta o tamanho para mobile se necessário
            if isMobile then
                if gui:FindFirstChild("Main") then
                    gui.Main.Size = UDim2.new(0, 300, 0, 400)
                end
            end
        end
    end
end)

-- Força a interface a ser visível após um pequeno delay
spawn(function()
    wait(1)
    for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
        if gui.Name == "KavoUI" then
            gui.Enabled = true
            gui.ResetOnSpawn = false
            -- Ajusta o tamanho para mobile se necessário
            if isMobile then
                if gui:FindFirstChild("Main") then
                    gui.Main.Size = UDim2.new(0, 300, 0, 400)
                end
            end
        end
    end
end) 
